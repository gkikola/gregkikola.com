<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Option++: optionpp::utility Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Option++
   &#160;<span id="projectnumber">2.0</span>
   </div>
   <div id="projectbrief">C++ library for reading command-line options</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceoptionpp.html">optionpp</a></li><li class="navelem"><a class="el" href="namespaceoptionpp_1_1utility.html">utility</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">optionpp::utility Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Namespace for utility functions.  
<a href="namespaceoptionpp_1_1utility.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5e9317035a84f5c1ee187cf874c0a63b"><td class="memTemplParams" colspan="2">template&lt;typename OutputIt &gt; </td></tr>
<tr class="memitem:a5e9317035a84f5c1ee187cf874c0a63b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoptionpp_1_1utility.html#a5e9317035a84f5c1ee187cf874c0a63b">split</a> (const std::string &amp;str, OutputIt dest, const std::string &amp;delims=&quot; \t\n\r&quot;, const std::string &amp;quotes=&quot;\&quot;\'&quot;, char escape_char='\\', bool allow_empty=false)</td></tr>
<tr class="memdesc:a5e9317035a84f5c1ee187cf874c0a63b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split a string over delimiters into substrings.  <a href="namespaceoptionpp_1_1utility.html#a5e9317035a84f5c1ee187cf874c0a63b">More...</a><br /></td></tr>
<tr class="separator:a5e9317035a84f5c1ee187cf874c0a63b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5bf81a38f1720d90b0b068d0a3180c0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoptionpp_1_1utility.html#af5bf81a38f1720d90b0b068d0a3180c0">wrap_text</a> (const std::string &amp;str, int line_len=79, int indent=0)</td></tr>
<tr class="memdesc:af5bf81a38f1720d90b0b068d0a3180c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform word-wrapping on a string.  <a href="namespaceoptionpp_1_1utility.html#af5bf81a38f1720d90b0b068d0a3180c0">More...</a><br /></td></tr>
<tr class="separator:af5bf81a38f1720d90b0b068d0a3180c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd6e3ec5c87576a9c850c0c28794877"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoptionpp_1_1utility.html#abbd6e3ec5c87576a9c850c0c28794877">wrap_text</a> (const std::string &amp;str, int line_len, int indent, int first_line_indent)</td></tr>
<tr class="memdesc:abbd6e3ec5c87576a9c850c0c28794877"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform word-wrapping on a string.  <a href="namespaceoptionpp_1_1utility.html#abbd6e3ec5c87576a9c850c0c28794877">More...</a><br /></td></tr>
<tr class="separator:abbd6e3ec5c87576a9c850c0c28794877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1f630ed05fef1e2d839c87463fce693"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoptionpp_1_1utility.html#af1f630ed05fef1e2d839c87463fce693">is_substr_at_pos</a> (const std::string &amp;str, const std::string &amp;substr, std::string::size_type pos=0) noexcept</td></tr>
<tr class="memdesc:af1f630ed05fef1e2d839c87463fce693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a string occurs within another string at a particular position.  <a href="namespaceoptionpp_1_1utility.html#af1f630ed05fef1e2d839c87463fce693">More...</a><br /></td></tr>
<tr class="separator:af1f630ed05fef1e2d839c87463fce693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d37b5415c54d2a460d12ccad9729518"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoptionpp_1_1utility.html#a5d37b5415c54d2a460d12ccad9729518">is_space</a> (char c)</td></tr>
<tr class="memdesc:a5d37b5415c54d2a460d12ccad9729518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a character is whitespace.  <a href="namespaceoptionpp_1_1utility.html#a5d37b5415c54d2a460d12ccad9729518">More...</a><br /></td></tr>
<tr class="separator:a5d37b5415c54d2a460d12ccad9729518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39903f8c26d2b95831c16a3cba7205a2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoptionpp_1_1utility.html#a39903f8c26d2b95831c16a3cba7205a2">wrap_line</a> (const std::string &amp;str, int line_len, int indent, int first_line_indent)</td></tr>
<tr class="memdesc:a39903f8c26d2b95831c16a3cba7205a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs word-wrapping for a single line of text.  <a href="namespaceoptionpp_1_1utility.html#a39903f8c26d2b95831c16a3cba7205a2">More...</a><br /></td></tr>
<tr class="separator:a39903f8c26d2b95831c16a3cba7205a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace for utility functions. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a5d37b5415c54d2a460d12ccad9729518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d37b5415c54d2a460d12ccad9729518">&#9670;&nbsp;</a></span>is_space()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool optionpp::utility::is_space </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a character is whitespace. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td>Character to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <code>c</code> is a whitespace character and false otherwise. </dd></dl>

</div>
</div>
<a id="af1f630ed05fef1e2d839c87463fce693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1f630ed05fef1e2d839c87463fce693">&#9670;&nbsp;</a></span>is_substr_at_pos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool optionpp::utility::is_substr_at_pos </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>substr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>pos</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if a string occurs within another string at a particular position. </p>
<p>This simple function checks <code>str</code> to see if <code>substr</code> is at the specified position. For example, the call </p><div class="fragment"><div class="line"><a class="code" href="namespaceoptionpp_1_1utility.html#af1f630ed05fef1e2d839c87463fce693">is_substr_at_pos</a>(<span class="stringliteral">&quot;Hello world&quot;</span>, <span class="stringliteral">&quot;wor&quot;</span>, 6)</div>
</div><!-- fragment --><p>should return true because the string "wor" does occur within "Hello world" at index 6.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>String in which substring is to be found. </td></tr>
    <tr><td class="paramname">substr</td><td>Substring to match. </td></tr>
    <tr><td class="paramname">pos</td><td>The position in <code>str</code> at which <code>substr</code> should be found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <code>substr</code> occurs at index <code>pos</code> in <code>str</code>, and false otherwise. </dd></dl>

</div>
</div>
<a id="a5e9317035a84f5c1ee187cf874c0a63b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e9317035a84f5c1ee187cf874c0a63b">&#9670;&nbsp;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputIt &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void optionpp::utility::split </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>delims</em> = <code>&quot;&#160;\t\n\r&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>quotes</em> = <code>&quot;\&quot;\'&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>escape_char</em> = <code>'\\'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_empty</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split a string over delimiters into substrings. </p>
<p>Splits a string into substring components using <code>delims</code> as token delimiters. If <code>allow_empty</code> is false, then empty components are skipped, unless enclosed in quotes.</p>
<p>Delimiters appearing within quote characters (as specified by the <code>quotes</code> parameter) are ignored. Within quotes, an escape character can be used to escape a quote symbol.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputIt</td><td>Type of output iterator (typically deduced). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The string to split. </td></tr>
    <tr><td class="paramname">dest</td><td>An output iterator specifying where the tokens should be written. </td></tr>
    <tr><td class="paramname">delims</td><td>String containing the characters to be used as delimiters. </td></tr>
    <tr><td class="paramname">quotes</td><td>String containing the allowed quote characters. </td></tr>
    <tr><td class="paramname">escape_char</td><td>Character to use as escape character. </td></tr>
    <tr><td class="paramname">allow_empty</td><td>If true, consecutive delimiters will produce empty substrings. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a39903f8c26d2b95831c16a3cba7205a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39903f8c26d2b95831c16a3cba7205a2">&#9670;&nbsp;</a></span>wrap_line()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string optionpp::utility::wrap_line </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first_line_indent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs word-wrapping for a single line of text. </p>
<p>This is a helper function for <code>wrap_text</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Text to wrap. </td></tr>
    <tr><td class="paramname">line_len</td><td>Maximum desired line length, if any. </td></tr>
    <tr><td class="paramname">indent</td><td>Number of spaces to indent each line. </td></tr>
    <tr><td class="paramname">first_line_indent</td><td>Number of spaces to indent the first line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Resulting word-wrapped string. </dd></dl>

</div>
</div>
<a id="abbd6e3ec5c87576a9c850c0c28794877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbd6e3ec5c87576a9c850c0c28794877">&#9670;&nbsp;</a></span>wrap_text() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string optionpp::utility::wrap_text </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first_line_indent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform word-wrapping on a string. </p>
<p>This function will take each line in the string and insert additional newlines in order to limit the maximum line length. Lines are only split between words unless there is no other choice.</p>
<p>To get an unlimited line length, set <code>line_len &lt;= 0</code>.</p>
<p>The text can also be indented a certain number of spaces. The total line length includes the indentation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Text to wrap. </td></tr>
    <tr><td class="paramname">line_len</td><td>Maximum desired line length, if any. </td></tr>
    <tr><td class="paramname">indent</td><td>Number of spaces to indent each line after the first one. </td></tr>
    <tr><td class="paramname">first_line_indent</td><td>Number of spaces to indent the first line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Resulting word-wrapped string. </dd></dl>

</div>
</div>
<a id="af5bf81a38f1720d90b0b068d0a3180c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5bf81a38f1720d90b0b068d0a3180c0">&#9670;&nbsp;</a></span>wrap_text() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string optionpp::utility::wrap_text </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line_len</em> = <code>79</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform word-wrapping on a string. </p>
<p>This function will take each line in the string and insert additional newlines in order to limit the maximum line length. Lines are only split between words unless there is no other choice.</p>
<p>To get an unlimited line length, set <code>line_len &lt;= 0</code>.</p>
<p>The text can also be indented a certain number of spaces. The total line length includes the indentation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>Text to wrap. </td></tr>
    <tr><td class="paramname">line_len</td><td>Maximum desired line length, if any. </td></tr>
    <tr><td class="paramname">indent</td><td>Number of spaces to indent each line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Resulting word-wrapped string. </dd></dl>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="anamespaceoptionpp_1_1utility_html_af1f630ed05fef1e2d839c87463fce693"><div class="ttname"><a href="namespaceoptionpp_1_1utility.html#af1f630ed05fef1e2d839c87463fce693">optionpp::utility::is_substr_at_pos</a></div><div class="ttdeci">bool is_substr_at_pos(const std::string &amp;str, const std::string &amp;substr, std::string::size_type pos=0) noexcept</div><div class="ttdoc">Determine if a string occurs within another string at a particular position.</div><div class="ttdef"><b>Definition:</b> utility.cpp:148</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
