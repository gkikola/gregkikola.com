<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Option++: optionpp::parser Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Option++
   &#160;<span id="projectnumber">2.0</span>
   </div>
   <div id="projectbrief">C++ library for reading command-line options</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceoptionpp.html">optionpp</a></li><li class="navelem"><a class="el" href="classoptionpp_1_1parser.html">parser</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classoptionpp_1_1parser-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">optionpp::parser Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Parses program options.  
 <a href="classoptionpp_1_1parser.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="parser_8hpp_source.html">parser.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3de2133f1d12887925221b4770e4db10"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoptionpp_1_1parser.html#a3de2133f1d12887925221b4770e4db10">parser</a> () noexcept</td></tr>
<tr class="memdesc:a3de2133f1d12887925221b4770e4db10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classoptionpp_1_1parser.html#a3de2133f1d12887925221b4770e4db10">More...</a><br /></td></tr>
<tr class="separator:a3de2133f1d12887925221b4770e4db10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8f5cd9209032fdf84b1f54d68a4b439"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoptionpp_1_1parser.html#ab8f5cd9209032fdf84b1f54d68a4b439">parser</a> (const std::initializer_list&lt; <a class="el" href="classoptionpp_1_1option.html">option</a> &gt; &amp;il)</td></tr>
<tr class="memdesc:ab8f5cd9209032fdf84b1f54d68a4b439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from an initializer list.  <a href="classoptionpp_1_1parser.html#ab8f5cd9209032fdf84b1f54d68a4b439">More...</a><br /></td></tr>
<tr class="separator:ab8f5cd9209032fdf84b1f54d68a4b439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affae3022b7a0b9aa1b301e5ff75f07a3"><td class="memTemplParams" colspan="2">template&lt;typename InputIt &gt; </td></tr>
<tr class="memitem:affae3022b7a0b9aa1b301e5ff75f07a3"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classoptionpp_1_1parser.html#affae3022b7a0b9aa1b301e5ff75f07a3">parser</a> (InputIt first, InputIt last)</td></tr>
<tr class="memdesc:affae3022b7a0b9aa1b301e5ff75f07a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a sequence.  <a href="classoptionpp_1_1parser.html#affae3022b7a0b9aa1b301e5ff75f07a3">More...</a><br /></td></tr>
<tr class="separator:affae3022b7a0b9aa1b301e5ff75f07a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f1ff9d6220ff20459ed47df1fb1a580"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoptionpp_1_1option__group.html">option_group</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoptionpp_1_1parser.html#a3f1ff9d6220ff20459ed47df1fb1a580">group</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a3f1ff9d6220ff20459ed47df1fb1a580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a reference to a particular group.  <a href="classoptionpp_1_1parser.html#a3f1ff9d6220ff20459ed47df1fb1a580">More...</a><br /></td></tr>
<tr class="separator:a3f1ff9d6220ff20459ed47df1fb1a580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7890627e53da5d584d0ddd349bee7be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoptionpp_1_1option.html">option</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoptionpp_1_1parser.html#ad7890627e53da5d584d0ddd349bee7be">add_option</a> (const <a class="el" href="classoptionpp_1_1option.html">option</a> &amp;opt=<a class="el" href="classoptionpp_1_1option.html">option</a>{})</td></tr>
<tr class="memdesc:ad7890627e53da5d584d0ddd349bee7be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a program option.  <a href="classoptionpp_1_1parser.html#ad7890627e53da5d584d0ddd349bee7be">More...</a><br /></td></tr>
<tr class="separator:ad7890627e53da5d584d0ddd349bee7be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acee8d03b6f7de473847ef5fafed94036"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoptionpp_1_1option.html">option</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoptionpp_1_1parser.html#acee8d03b6f7de473847ef5fafed94036">add_option</a> (const std::string &amp;long_name, char short_name='\0', const std::string &amp;description=&quot;&quot;, const std::string &amp;arg_name=&quot;&quot;, bool arg_required=false, const std::string &amp;group_name=&quot;&quot;)</td></tr>
<tr class="memdesc:acee8d03b6f7de473847ef5fafed94036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a program option.  <a href="classoptionpp_1_1parser.html#acee8d03b6f7de473847ef5fafed94036">More...</a><br /></td></tr>
<tr class="separator:acee8d03b6f7de473847ef5fafed94036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae811f10836a7306db94b7a9f95f0a692"><td class="memTemplParams" colspan="2">template&lt;typename InputIt &gt; </td></tr>
<tr class="memitem:ae811f10836a7306db94b7a9f95f0a692"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoptionpp_1_1parser__result.html">parser_result</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classoptionpp_1_1parser.html#ae811f10836a7306db94b7a9f95f0a692">parse</a> (InputIt first, InputIt last, bool ignore_first=true) const</td></tr>
<tr class="memdesc:ae811f10836a7306db94b7a9f95f0a692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse command-line arguments from a sequence of strings.  <a href="classoptionpp_1_1parser.html#ae811f10836a7306db94b7a9f95f0a692">More...</a><br /></td></tr>
<tr class="separator:ae811f10836a7306db94b7a9f95f0a692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad309fe269f32c3dcfef7af3a753e5d30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoptionpp_1_1parser__result.html">parser_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoptionpp_1_1parser.html#ad309fe269f32c3dcfef7af3a753e5d30">parse</a> (int argc, char *argv[], bool ignore_first=true) const</td></tr>
<tr class="memdesc:ad309fe269f32c3dcfef7af3a753e5d30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse command-line arguments.  <a href="classoptionpp_1_1parser.html#ad309fe269f32c3dcfef7af3a753e5d30">More...</a><br /></td></tr>
<tr class="separator:ad309fe269f32c3dcfef7af3a753e5d30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b209bdb9ceaae23679c10dbf470dbc5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoptionpp_1_1parser__result.html">parser_result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoptionpp_1_1parser.html#a1b209bdb9ceaae23679c10dbf470dbc5">parse</a> (const std::string &amp;cmd_line, bool ignore_first=false) const</td></tr>
<tr class="memdesc:a1b209bdb9ceaae23679c10dbf470dbc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse command-line arguments from a string.  <a href="classoptionpp_1_1parser.html#a1b209bdb9ceaae23679c10dbf470dbc5">More...</a><br /></td></tr>
<tr class="separator:a1b209bdb9ceaae23679c10dbf470dbc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5034aaedf9eaa58dd391cce7660d0450"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoptionpp_1_1parser.html#a5034aaedf9eaa58dd391cce7660d0450">set_custom_strings</a> (const std::string &amp;delims, const std::string &amp;short_prefix=&quot;&quot;, const std::string &amp;long_prefix=&quot;&quot;, const std::string &amp;end_indicator=&quot;&quot;, const std::string &amp;equals=&quot;&quot;)</td></tr>
<tr class="memdesc:a5034aaedf9eaa58dd391cce7660d0450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change special strings used by the parser.  <a href="classoptionpp_1_1parser.html#a5034aaedf9eaa58dd391cce7660d0450">More...</a><br /></td></tr>
<tr class="separator:a5034aaedf9eaa58dd391cce7660d0450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2e6839aabbf6db42e09fd0c2819b70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoptionpp_1_1parser.html#ade2e6839aabbf6db42e09fd0c2819b70">sort_groups</a> ()</td></tr>
<tr class="memdesc:ade2e6839aabbf6db42e09fd0c2819b70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the groups by name.  <a href="classoptionpp_1_1parser.html#ade2e6839aabbf6db42e09fd0c2819b70">More...</a><br /></td></tr>
<tr class="separator:ade2e6839aabbf6db42e09fd0c2819b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a908e667b1dfce5ff614c12ba7c0e8575"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoptionpp_1_1parser.html#a908e667b1dfce5ff614c12ba7c0e8575">sort_options</a> ()</td></tr>
<tr class="memdesc:a908e667b1dfce5ff614c12ba7c0e8575"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts all options by name.  <a href="classoptionpp_1_1parser.html#a908e667b1dfce5ff614c12ba7c0e8575">More...</a><br /></td></tr>
<tr class="separator:a908e667b1dfce5ff614c12ba7c0e8575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a219a47058d483a0882bb7293d539bd1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoptionpp_1_1option.html">option</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoptionpp_1_1parser.html#a219a47058d483a0882bb7293d539bd1c">operator[]</a> (const std::string &amp;long_name)</td></tr>
<tr class="memdesc:a219a47058d483a0882bb7293d539bd1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscript operator.  <a href="classoptionpp_1_1parser.html#a219a47058d483a0882bb7293d539bd1c">More...</a><br /></td></tr>
<tr class="separator:a219a47058d483a0882bb7293d539bd1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b24719d3ead229631585f91a46be43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoptionpp_1_1option.html">option</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoptionpp_1_1parser.html#ae7b24719d3ead229631585f91a46be43">operator[]</a> (char short_name)</td></tr>
<tr class="memdesc:ae7b24719d3ead229631585f91a46be43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscript operator.  <a href="classoptionpp_1_1parser.html#ae7b24719d3ead229631585f91a46be43">More...</a><br /></td></tr>
<tr class="separator:ae7b24719d3ead229631585f91a46be43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9071bdb172ee5168e1d646af9274c283"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoptionpp_1_1parser.html#a9071bdb172ee5168e1d646af9274c283">print_help</a> (std::ostream &amp;os, int max_line_length=78, int group_indent=0, int option_indent=2, int desc_first_line_indent=30, int desc_multiline_indent=32) const</td></tr>
<tr class="memdesc:a9071bdb172ee5168e1d646af9274c283"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print program help message.  <a href="classoptionpp_1_1parser.html#a9071bdb172ee5168e1d646af9274c283">More...</a><br /></td></tr>
<tr class="separator:a9071bdb172ee5168e1d646af9274c283"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Parses program options. </p>
<p>A <code>parser</code> accepts program option information in the form of <code>option</code> objects, which may be passed to the constructor or added after construction with the add_option method. After all options have been specified, the <code>parse</code> method may then be called with the command-line arguments that were passed to the program. This will produce a <code><a class="el" href="classoptionpp_1_1parser__result.html" title="Holds data that was parsed from the program command line.">parser_result</a></code> containing the parsed information.</p>
<p>For more information about the argument parsing, refer to the documentation for the <code>parse</code> method.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classoptionpp_1_1option.html" title="Describes a valid program command-line option.">option</a> </dd>
<dd>
<a class="el" href="classoptionpp_1_1parser__result.html" title="Holds data that was parsed from the program command line.">parser_result</a> </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3de2133f1d12887925221b4770e4db10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de2133f1d12887925221b4770e4db10">&#9670;&nbsp;</a></span>parser() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">optionpp::parser::parser </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>No program options are accepted by default. Acceptable options can later be specified using the <code>add_option</code> method. </p>

</div>
</div>
<a id="ab8f5cd9209032fdf84b1f54d68a4b439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8f5cd9209032fdf84b1f54d68a4b439">&#9670;&nbsp;</a></span>parser() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">optionpp::parser::parser </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; <a class="el" href="classoptionpp_1_1option.html">option</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>il</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from an initializer list. </p>
<p>Each <code>option</code> provided in the list specifies an acceptable program option that can be given on the command line.</p>
<p>The options are added to the nameless default group.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">il</td><td>The <code>initializer_list</code> containing the acceptable program options. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classoptionpp_1_1option.html" title="Describes a valid program command-line option.">option</a> </dd></dl>

</div>
</div>
<a id="affae3022b7a0b9aa1b301e5ff75f07a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affae3022b7a0b9aa1b301e5ff75f07a3">&#9670;&nbsp;</a></span>parser() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">optionpp::parser::parser </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct from a sequence. </p>
<p>Each <code>option</code> in the sequence specifies an acceptable program option that can be given on the command line.</p>
<p>The options are added to the nameless default group.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">InputIt</td><td>The iterator type (usually deduced). </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The iterator pointing to the start of the sequence. </td></tr>
    <tr><td class="paramname">last</td><td>The iterator pointing to one past the end of the sequence. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad7890627e53da5d584d0ddd349bee7be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7890627e53da5d584d0ddd349bee7be">&#9670;&nbsp;</a></span>add_option() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoptionpp_1_1option.html">option</a> &amp; optionpp::parser::add_option </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoptionpp_1_1option.html">option</a> &amp;&#160;</td>
          <td class="paramname"><em>opt</em> = <code><a class="el" href="classoptionpp_1_1option.html">option</a>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a program option. </p>
<p>The given <code>option</code> instance (if any) will specify information about a program option that the user can set on the command line, such as the option's long name, short name, description, and so on.</p>
<p>Note that the method returns a reference to the instance of the <code>option</code> that was inserted to allow chaining. For example: </p><div class="fragment"><div class="line">opt_parser.add_option()</div>
<div class="line">          .long_name(<span class="stringliteral">&quot;verbose&quot;</span>)</div>
<div class="line">          .short_name(<span class="charliteral">&#39;v&#39;</span>)</div>
<div class="line">          .description(<span class="stringliteral">&quot;Show verbose output.&quot;</span>);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">opt</td><td>The <code>option</code> to add. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the inserted <code>option</code>, for chaining. </dd></dl>

</div>
</div>
<a id="acee8d03b6f7de473847ef5fafed94036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acee8d03b6f7de473847ef5fafed94036">&#9670;&nbsp;</a></span>add_option() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoptionpp_1_1option.html">option</a> &amp; optionpp::parser::add_option </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>long_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>short_name</em> = <code>'\0'</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>description</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>arg_name</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>arg_required</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>group_name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a program option. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">long_name</td><td>Long name for the option. </td></tr>
    <tr><td class="paramname">short_name</td><td>Short name for the option. </td></tr>
    <tr><td class="paramname">description</td><td>Option description (for help message). </td></tr>
    <tr><td class="paramname">arg_name</td><td>Argument name, if any (usually uppercase) </td></tr>
    <tr><td class="paramname">arg_required</td><td>Set to true if argument is mandatory. </td></tr>
    <tr><td class="paramname">group_name</td><td>Name of group option should be added to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the inserted <code>option</code>, for chaining. </dd></dl>

</div>
</div>
<a id="a3f1ff9d6220ff20459ed47df1fb1a580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f1ff9d6220ff20459ed47df1fb1a580">&#9670;&nbsp;</a></span>group()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoptionpp_1_1option__group.html">option_group</a> &amp; optionpp::parser::group </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a reference to a particular group. </p>
<p>The group is created if it does not exist.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the group. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the group. </dd></dl>

</div>
</div>
<a id="ae7b24719d3ead229631585f91a46be43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7b24719d3ead229631585f91a46be43">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoptionpp_1_1option.html">option</a> &amp; optionpp::parser::operator[] </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>short_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subscript operator. </p>
<p>Returns the specified option or creates it if it doesn't exist.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">short_name</td><td>Short name for the option. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matching option or newly created one if it didn't already exist. </dd></dl>

</div>
</div>
<a id="a219a47058d483a0882bb7293d539bd1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a219a47058d483a0882bb7293d539bd1c">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoptionpp_1_1option.html">option</a> &amp; optionpp::parser::operator[] </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>long_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subscript operator. </p>
<p>Returns the specified option or creates it if it doesn't exist.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">long_name</td><td>Long name for the option. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matching option or newly created one if it didn't already exist. </dd></dl>

</div>
</div>
<a id="a1b209bdb9ceaae23679c10dbf470dbc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b209bdb9ceaae23679c10dbf470dbc5">&#9670;&nbsp;</a></span>parse() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoptionpp_1_1parser__result.html">parser_result</a> optionpp::parser::parse </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>cmd_line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_first</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse command-line arguments from a string. </p>
<p>For full details, see the description of the <code>parse(InputIt, InputIt, bool)</code> overload. This version of the function will split the string over whitespace to tokenize the input. Quotes can be used within the string to specify arguments containing whitespace. A backslash can be used to start an escape sequence within an argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cmd_line</td><td>The command-line arguments to parse. </td></tr>
    <tr><td class="paramname">ignore_first</td><td>If true, the first argument is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="classoptionpp_1_1parser__result.html" title="Holds data that was parsed from the program command line.">parser_result</a></code> containing the parsed data. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classoptionpp_1_1parse__error.html" title="Exception class indicating an invalid option.">parse_error</a></td><td>If an invalid option is entered or a mandatory argument is missing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classoptionpp_1_1parser__result.html" title="Holds data that was parsed from the program command line.">parser_result</a> </dd></dl>

</div>
</div>
<a id="ae811f10836a7306db94b7a9f95f0a692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae811f10836a7306db94b7a9f95f0a692">&#9670;&nbsp;</a></span>parse() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIt &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoptionpp_1_1parser__result.html">parser_result</a> optionpp::parser::parse </td>
          <td>(</td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIt&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_first</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse command-line arguments from a sequence of strings. </p>
<p>Accepts the usual arguments that are normally supplied to <code>main</code>, scans them for program options (these will be arguments starting with a hyphen or double-hyphen) and stores the options together with the non-option arguments in a <code><a class="el" href="classoptionpp_1_1parser__result.html" title="Holds data that was parsed from the program command line.">parser_result</a></code> object.</p>
<p>Each option can have a short name consisting of a single character (following a hyphen), or a long name (following a double-hyphen), or both. For example, an option called <code>verbose</code> with a short name of <code>v</code> could be specified either as <code>--verbose</code> or as <code>-v</code>.</p>
<p>Multiple short names can be specified in a single argument. For example <code>-abc</code> would specify three options with respective short names <code>a</code>, <code>b</code>, and <code>c</code>.</p>
<p>Some options may accept arguments. Arguments can be supplied in several ways: for long names, the usual form is <code>--long-name=argument</code> and for short names <code>-X argument</code>. The parser will also accept <code>--long-name argument</code>, <code>-X=argument</code>, and <code>-Xargument</code>.</p>
<p>A double-hyphen (<code>--</code>) by itself can be used to indicate the end of program options. Any remaining command line arguments are then interpreted as non-option arguments. A single hyphen (<code>-</code>) by itself is considered a non-option argument (this is often used as a way to specify standard input instead of a filename).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>An iterator pointing to the first argument. </td></tr>
    <tr><td class="paramname">last</td><td>An iterator pointing to one past the last argument. </td></tr>
    <tr><td class="paramname">ignore_first</td><td>If true, the first argument (typically the program filename) is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="classoptionpp_1_1parser__result.html" title="Holds data that was parsed from the program command line.">parser_result</a></code> containing the parsed data. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classoptionpp_1_1parse__error.html" title="Exception class indicating an invalid option.">parse_error</a></td><td>If an invalid option is entered or a mandatory argument is missing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classoptionpp_1_1parser__result.html" title="Holds data that was parsed from the program command line.">parser_result</a> </dd></dl>

</div>
</div>
<a id="ad309fe269f32c3dcfef7af3a753e5d30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad309fe269f32c3dcfef7af3a753e5d30">&#9670;&nbsp;</a></span>parse() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoptionpp_1_1parser__result.html">parser_result</a> optionpp::parser::parse </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>argv</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_first</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse command-line arguments. </p>
<p>Accepts the usual arguments that are normally supplied to <code>main</code>. For further details, see the description of the <code>parse(InputIt, InputIt, bool)</code> overload.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">argc</td><td>The number of arguments given on the command line. </td></tr>
    <tr><td class="paramname">argv</td><td>All command-line arguments. </td></tr>
    <tr><td class="paramname">ignore_first</td><td>If true, the first argument (typically the program filename) is ignored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="classoptionpp_1_1parser__result.html" title="Holds data that was parsed from the program command line.">parser_result</a></code> containing the parsed data. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">parser_error</td><td>If an invalid option is entered or a mandatory argument is missing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classoptionpp_1_1parser__result.html" title="Holds data that was parsed from the program command line.">parser_result</a> </dd></dl>

</div>
</div>
<a id="a9071bdb172ee5168e1d646af9274c283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9071bdb172ee5168e1d646af9274c283">&#9670;&nbsp;</a></span>print_help()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; optionpp::parser::print_help </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_line_length</em> = <code>78</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>group_indent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>option_indent</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>desc_first_line_indent</em> = <code>30</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>desc_multiline_indent</em> = <code>32</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print program help message. </p>
<p>This will write all program options, organized by group, to the given output stream. The additional parameters control the formatting.</p>
<p>The options are presented in the order that they were added to each group; if desired, you can call <code>sort_options</code> first to sort the options by name within each group.</p>
<p>Option names and descriptions are displayed in columns, with option names on the left and descriptions on the right. The first line of a description will begin on the same line as the option names, unless there's not enough room, in which case a new line is started.</p>
<p>The indentation levels are not cumulative: each parameter gives the total level of indentation, counted from the leftmost character of the line.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Output stream. </td></tr>
    <tr><td class="paramname">max_line_length</td><td>Text will be wrapped so that each line is at most this many characters. </td></tr>
    <tr><td class="paramname">group_indent</td><td>Number of spaces to indent group names. </td></tr>
    <tr><td class="paramname">option_indent</td><td>Number of spaces to indent option names. </td></tr>
    <tr><td class="paramname">desc_first_line_indent</td><td>Number of spaces to indent first line of each description. </td></tr>
    <tr><td class="paramname">desc_multiline_indent</td><td>Number of spaces to indent descriptions after the first line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output stream that was initially given. </dd></dl>

</div>
</div>
<a id="a5034aaedf9eaa58dd391cce7660d0450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5034aaedf9eaa58dd391cce7660d0450">&#9670;&nbsp;</a></span>set_custom_strings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void optionpp::parser::set_custom_strings </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>delims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>short_prefix</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>long_prefix</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>end_indicator</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>equals</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change special strings used by the parser. </p>
<p>With this method, you can set custom option prefixes and such. For each parameter, a blank string indicates that the old string should be kept.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delims</td><td>Whitespace delimiters used to separate arguments. </td></tr>
    <tr><td class="paramname">short_prefix</td><td>Prefix that indicates a group of short option names. </td></tr>
    <tr><td class="paramname">long_prefix</td><td>Prefix that indicates a long option name. </td></tr>
    <tr><td class="paramname">end_indicator</td><td>Mark that indicates that all remaining arguments should be interpreted as non-option arguments. </td></tr>
    <tr><td class="paramname">equals</td><td>String that indicates an explicit option argument. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade2e6839aabbf6db42e09fd0c2819b70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade2e6839aabbf6db42e09fd0c2819b70">&#9670;&nbsp;</a></span>sort_groups()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void optionpp::parser::sort_groups </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts the groups by name. </p>
<p>By default groups are kept in the order that they were added. </p>

</div>
</div>
<a id="a908e667b1dfce5ff614c12ba7c0e8575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a908e667b1dfce5ff614c12ba7c0e8575">&#9670;&nbsp;</a></span>sort_options()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void optionpp::parser::sort_options </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts all options by name. </p>
<p>By default, options within each group are kept in the order that they were added. This method will sort all the options in each group so that they are ordered by name (either by their long name, or by their short name if the long name doesn't exist). </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/gkikola/Code/optionpp/include/optionpp/<a class="el" href="parser_8hpp_source.html">parser.hpp</a></li>
<li>/home/gkikola/Code/optionpp/src/<a class="el" href="parser_8cpp.html">parser.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
